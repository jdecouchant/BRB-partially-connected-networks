import sys

import numpy as np

from statistics import stdev
from statistics import median

from scipy.stats import f_oneway

import matplotlib.pyplot as plt

color = sys.stdout.shell

fname = 'sync_MBD_7_11.txt' # generated by benchEachOptionAlone_7_11.py
##fname = 'table2.full.1024'

FILTER_ANOVA = False
ROUND_VAL = 2
option_cmp_to_mbd1 = True

f = open(fname, 'r')

c = 0

max_tops = 13
key = ''
top_msgs_options = {} #[]
top_lat_options = {} #[]
top_net_options = {} #[]

max_latency = 0 # to update
max_net = 0 # to update
max_msgs = 0 # to update

cur_options = ''

msgs = 0
lat = 0
net = 0

base_msgs = 0
base_lat = 0
base_net = 0

is_base = False
base_failed = False

is_mbd1 = False

for l in f:
    
    if 'False' in l or 'True' in l:
        cur_options = l.rstrip('\n')
        l = cur_options.split('\t')
        
        only_options = "\t".join(l[9:21])
        if only_options == "\t".join(['False']*12):
            is_base = True
        else:
            is_base = False
            
        if option_cmp_to_mbd1 and only_options == "True\t"+"\t".join(['False']*11):
            is_mbd1 = True
        else:
            is_mbd1 = False
        
        key = str(l[0])+' '+str(l[1])+' '+\
              str(l[2])+' '+str(l[3])
        
        if not key in top_msgs_options:
            top_msgs_options[key] = {}
            top_lat_options[key] = {}
            top_net_options[key] = {}
        if not cur_options in top_msgs_options[key]:
            top_msgs_options[key][cur_options] = []
            top_lat_options[key][cur_options] = []
            top_net_options[key][cur_options] = []
        
    if 'Num messages:' in l:
        l = l.rstrip('\n').split(' ')
        msgs = float(l[2])

        if is_base:
            base_msgs = msgs
            base_lat = lat
            base_net = net

        if is_mbd1:
            base_msgs = msgs
            base_lat = lat
            base_net = net
        
        if lat != -1 and (not base_failed):
            top_msgs_options[key][cur_options].append([base_msgs, msgs])
            top_lat_options[key][cur_options].append([base_lat, lat])
            top_net_options[key][cur_options].append([base_net, net])

    if 'Latency' in l:
         l = l.rstrip('\n').split(' ')
         lat = float(l[1])
         if is_base or is_mbd1:
##             base_lat = lat
             if lat == -1:
                 base_failed = True
             else:
                 base_failed = False
             
         
    if 'Net consumption' in l:
        l = l.rstrip('\n').split(' ')
        net = float(l[2])
##        if is_base or is_mbd1:
##            base_net = net

f.close()

def compare(key1, key2):
    
    s1 = key1.split(' ')
    s2 = key2.split(' ')
    if float(s1[0]) < float(s2[0]):
        return -1
    elif float(s1[0]) == float(s2[0]) and float(s1[1]) < float(s2[1]):
        return -1
    elif float(s1[0]) == float(s2[0]) and float(s1[1]) == float(s2[1]) and float(s1[2]) < float(s2[2]):
        return -1
    elif float(s1[0]) == float(s2[0]) and float(s1[1]) == float(s2[1]) and float(s1[2]) == float(s2[2]) and float(s1[3]) < float(s2[3]):
        return -1
    elif float(s1[0]) == float(s2[0]) and float(s1[1]) == float(s2[1]) and float(s1[2]) == float(s2[2]) and float(s1[3]) == float(s2[3]):
        return 0
    return 1

base_msgs = 0
base_net = 0
base_lat = 0

import functools

### Print results

for k in sorted(top_msgs_options, key=functools.cmp_to_key(compare)):
    # k: 'N f k payloadSize'

    is_base = True
    s = k.split(' ')
    print('Configuration N='+s[0]+', f='+s[1]+', k='+s[2]+', payload='+s[3]+' (Msgs, Net, Lat)')
    cid = 0
    base_options = ''
    connectivity = int(s[2])

    for cur_options in top_msgs_options[k]:
        c = cur_options.split('\t')
        c = "\t".join(c[9:21])

        if c  == "True\t"+"\t".join(['False']*11):
            cid = 1
        elif c  == "True\t"+"\t".join(['False']*5)+"\tTrue\t"+"\t".join(['False']*5):
            cid = 7
        elif c  == "True\t"+"\t".join(['False']*9)+"\tTrue\tFalse":
            cid = 11

        is_base = False
        if c == "\t".join(['False']*12):
            is_base = True

        l1 = []
        l2 = []
        l3 = []

        bl1 = []
        bl2 = []
        bl3 = []
        
        for i in range(len(top_msgs_options[k][cur_options])):
            l1.append(top_msgs_options[k][cur_options][i][1])
            l2.append(top_net_options[k][cur_options][i][1])
            l3.append(top_lat_options[k][cur_options][i][1])

            bl1.append(top_msgs_options[k][cur_options][i][0])
            bl2.append(top_net_options[k][cur_options][i][0])
            bl3.append(top_lat_options[k][cur_options][i][0])

        if len(l1) > 0:
            a0 = sum(l1)/len(l1)
            b0 = sum(l2)/len(l2)
            c0 = sum(l3)/len(l3)
        else:
            a0 = -1
            b0 = -1
            c0 = -1
        
        if is_base:
            base_options = cur_options
            base_msgs = a0
            base_net = b0
            base_lat = c0

        if len(l1) > 1:
            anova_msgs = f_oneway(bl1, l1).pvalue # reject if p-value lower than l1)>0:0.05 (i.e., significant difference)
            anova_net = f_oneway(bl2, l2).pvalue # reject if p-value lower than 0.05 (i.e., significant difference)
            anova_lat = f_oneway(bl3, l3).pvalue # reject if p-value lower than 0.05 (i.e., significant difference)
        else:
            anova_msgs = 1.0
            anova_net = 1.0
            anova_lat = 1.0

        dl1 = []
        dl2 = []
        dl3 = []
        for i in range(len(l1)):
            dl1.append(100 * (l1[i]-bl1[i])/bl1[i])
            dl2.append(100 * (l2[i]-bl2[i])/bl2[i])
            dl3.append(100 * (l3[i]-bl3[i])/bl3[i])

        if len(dl1) > 0:
            a = sum(dl1) / len(dl1) 
            b = sum(dl2) / len(dl2)
            c = sum(dl3) / len(dl3)
        else:
            a = -1
            b = -1
            c = -1
                       
        print('MBD.'+str(cid)+' ('+str(len(l1))+'pts)\t', end='')

        if FILTER_ANOVA and anova_msgs >= 0.05:
            print("()\t", end='')
        else:

            if len(l1) > 1:
                m = '('+str(round(a0, ROUND_VAL))+':'+str(round(a, ROUND_VAL))+'%, '+str(round(stdev(l1), ROUND_VAL))
            else:
                m = '('+str(round(a0, ROUND_VAL))+':'+str(round(a, ROUND_VAL))+'%, 0'
            col = 'KEYWORD'
            if not is_base:
                if a <= 0:
                    col = 'STRING'
                else:
                    col = 'COMMENT'
                color.write(m+',', col)
            else:
                print(m, end='')

            col = 'KEYWORD'
            if not is_base:
                if anova_msgs < 0.05:
                    col = 'STRING'
                else:
                    col = 'COMMENT'            
                color.write(str(round(anova_msgs, ROUND_VAL))+')\t', col)
            else:
                print(')\t', end='')

        if FILTER_ANOVA and anova_net >= 0.05:
            print("()\t", end='')
        else:
            if len(l2)>1:
                m = '('+str(round(b0, ROUND_VAL))+':'+str(round(b, ROUND_VAL))+'%, '+str(round(stdev(l2), ROUND_VAL))
            else:
                m = '('+str(round(b0, ROUND_VAL))+':'+str(round(b, ROUND_VAL))+'%, 0'
            col = 'KEYWORD'
            if not is_base:
                if b < 0:
                    col = 'STRING'
                else:
                    col = 'COMMENT'
                color.write(m+',', col)
            else:
                print(m, end='')
                
            col = 'KEYWORD'
            if not is_base:
                if anova_net < 0.05:
                    col = 'STRING'
                else:
                    col = 'COMMENT'
                color.write(str(round(anova_net, ROUND_VAL))+')\t', col)
            else:
                print(')\t', end='')

        if FILTER_ANOVA and anova_lat >= 0.05:
            print("()\t", end='')
        else:
            if len(l3)>1:
                m = '('+str(round(c0, ROUND_VAL))+':'+str(round(c, ROUND_VAL))+'%, '+str(round(stdev(l3), ROUND_VAL))
            else:
                m = '('+str(round(c0, ROUND_VAL))+':'+str(round(c, ROUND_VAL))+'%, 0'
            col = 'KEYWORD'
            if not is_base:
                if c < 0:
                    col = 'STRING'
                else:
                    col = 'COMMENT'
                color.write(m+',', col)
            else:
                print(m, end='')

            col = 'KEYWORD'
            if not is_base:
                if anova_lat < 0.05:
                    col = 'STRING'
                else:
                    col = 'COMMENT'
                color.write(str(round(anova_lat, ROUND_VAL))+')\t', col)
            else:
                print(')\t', end='')
                
        print()
                  
        cid += 1
    print()

statsPerMBD = {}
statsPerMBD['msg'] = {}
statsPerMBD['lat'] = {}
statsPerMBD['net'] = {}

for k in sorted(top_msgs_options, key=functools.cmp_to_key(compare)):
    # k: 'N f k payloadSize'
    
    is_base = True
    s = k.split(' ')
##    print('Configuration N='+s[0]+', f='+s[1]+', k='+s[2]+', payload='+s[3]+' (Msgs, Net, Lat)')
    cid = 0
    base_options = ''

    connectivity = int(s[2])

    for cur_options in top_msgs_options[k]: # for all possible options with 'N f k payloadSize'
        c = cur_options.split('\t')
        c = "\t".join(c[9:21])

        if c  == "True\t"+"\t".join(['False']*11):
            cid = 1
        elif c  == "True\t"+"\t".join(['False']*5)+"\tTrue\t"+"\t".join(['False']*5):
            cid = 7
        elif c  == "True\t"+"\t".join(['False']*9)+"\tTrue\tFalse":
            cid = 11

        if not cid in statsPerMBD['lat']:
            statsPerMBD['msg'][cid] = {}
            statsPerMBD['lat'][cid] = {}
            statsPerMBD['net'][cid] = {}
        if not s[2] in statsPerMBD['lat'][cid]:
            statsPerMBD['msg'][cid][connectivity] = []
            statsPerMBD['lat'][cid][connectivity] = []
            statsPerMBD['net'][cid][connectivity] = []

        l1 = []
        l2 = []
        l3 = []

        bl1 = []
        bl2 = []
        bl3 = []
        
        for i in range(len(top_msgs_options[k][cur_options])):
            l1.append(top_msgs_options[k][cur_options][i][1])
            l2.append(top_net_options[k][cur_options][i][1])
            l3.append(top_lat_options[k][cur_options][i][1])

            bl1.append(top_msgs_options[k][cur_options][i][0])
            bl2.append(top_net_options[k][cur_options][i][0])
            bl3.append(top_lat_options[k][cur_options][i][0])

##            print(top_lat_options[k][cur_options][i][1],
##                  top_lat_options[k][cur_options][i][0])

        for i in range(len(l1)):
##            print(100 * (l3[i]-bl3[i])/bl3[i])
            statsPerMBD['msg'][cid][connectivity].append(100 * (l1[i]-bl1[i])/bl1[i])
            statsPerMBD['net'][cid][connectivity].append(100 * (l2[i]-bl2[i])/bl2[i])
            statsPerMBD['lat'][cid][connectivity].append(100 * (l3[i]-bl3[i])/bl3[i])  

        cid += 1



# f = 1, 5, 9, 13
# k = 4, 10, 16, 22, 28, 34, 40, 46

##SMALL_SIZE = 8
##MEDIUM_SIZE = 10
##BIGGER_SIZE = 12
##
##plt.rc('font', size=BIGGER_SIZE)          # controls default text sizes
##plt.rc('axes', titlesize=BIGGER_SIZE)     # fontsize of the axes title
##plt.rc('axes', labelsize=BIGGER_SIZE)    # fontsize of the x and y labels
####plt.rc('xtick', labelsize='x-large')    # fontsize of the tick labels
####plt.rc('ytick', labelsize=BIGGER_SIZE)    # fontsize of the tick labels
##plt.rc('legend', fontsize=BIGGER_SIZE)    # legend fontsize
##plt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title
##
##x = {}
##y = {}
##nonAvgY = {}
##for f in [1, 5, 9, 13]:
##    x[f] = []
##    y[f] = []
##    nonAvgY[f] = []
##    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
##        if k < 2*f + 1:
##            continue
##        x[f].append(k)
##        avgLatDec = 0
##        for i in range(len(statsPerMBD['lat'][7][k])):
##            avgLatDec += statsPerMBD['lat'][7][k][i]
##            nonAvgY[f].append(statsPerMBD['lat'][7][k][i])
##        avgLatDec /= len(statsPerMBD['lat'][7][k])
##        y[f].append(avgLatDec)
##
##fig, ax = plt.subplots()
##
### We change the fontsize of minor ticks label 
##ax.tick_params(axis='both', which='major', labelsize=20)
##ax.tick_params(axis='both', which='minor', labelsize=20)
##
##
##ax.errorbar(x[1], y[1], yerr=np.std(nonAvgY[1]), marker='o', linestyle='solid', label='f=1')
##ax.errorbar(x[5], y[5], yerr=np.std(nonAvgY[5]), marker='x', linestyle='dotted', label='f=5')
##ax.errorbar(x[9], y[9], yerr=np.std(nonAvgY[9]), marker='^', linestyle='dashed', label='f=9')
##ax.errorbar(x[13], y[13], yerr=np.std(nonAvgY[13]), marker='+', linestyle='dashdot', label='f=13')
##
##
##ax.legend()
##
##
##ax.set_xlabel('Network connectivity (k)')
##ax.set_ylabel('Variation latency (%)')
###ax.set_title('Line plot with error bars')
##
##plt.xlim([0, 50])
##plt.xticks([0,5,10,15,20,25,30,35,40,45,50])
##
##print(x[1])
##print(y[1])
##print(x[5])
##print(y[5])
##print(x[9])
##print(y[9])
##print(x[13])
##print(y[13])

# Fig 4 (with MBD.7)
##plt.show()
#plt.savefig("journal_fig4_mbd7.pdf", bbox_inches='tight')

##x = {}
##y = {}
##nonAvgY = {}
##for f in [1, 5, 9, 13]:
##    x[f] = []
##    y[f] = []
##    nonAvgY[f] = []
##    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
##        if k < 2*f + 1:
##            continue
##        x[f].append(k)
##        avgLatDec = 0
##        for i in range(len(statsPerMBD['lat'][11][k])):
##            avgLatDec += statsPerMBD['lat'][11][k][i]
##            nonAvgY[f].append(statsPerMBD['lat'][11][k][i])
##        avgLatDec /= len(statsPerMBD['lat'][11][k])
##        y[f].append(avgLatDec)
##
##fig, ax = plt.subplots()
##
### We change the fontsize of minor ticks label 
##ax.tick_params(axis='both', which='major', labelsize=20)
##ax.tick_params(axis='both', which='minor', labelsize=20)
##
##
##ax.errorbar(x[1], y[1], yerr=np.std(nonAvgY[1]), marker='o', linestyle='solid', label='f=1')
##ax.errorbar(x[5], y[5], yerr=np.std(nonAvgY[5]), marker='x', linestyle='dotted', label='f=5')
##ax.errorbar(x[9], y[9], yerr=np.std(nonAvgY[9]), marker='^', linestyle='dashed', label='f=9')
##ax.errorbar(x[13], y[13], yerr=np.std(nonAvgY[13]), marker='+', linestyle='dashdot', label='f=13')
##
##
##ax.legend()
##
##
##ax.set_xlabel('Network connectivity (k)')
##ax.set_ylabel('Variation latency (%)')
###ax.set_title('Line plot with error bars')
##
##plt.xlim([0, 50])
##plt.xticks([0,5,10,15,20,25,30,35,40,45,50])

# Fig 5 (with MBD.11)
#plt.savefig("journal_fig5_mbd11.pdf", bbox_inches='tight')
##plt.show()


################### Now plotting network consumption

##x = {}
##y = {}
##nonAvgY = {}
##for f in [1, 5, 9, 13]:
##    x[f] = []
##    y[f] = []
##    nonAvgY[f] = []
##    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
##        if k < 2*f + 1:
##            continue
##        x[f].append(k)
##        avgLatDec = 0
##        for i in range(len(statsPerMBD['net'][7][k])):
##            avgLatDec += statsPerMBD['net'][7][k][i]
##            nonAvgY[f].append(statsPerMBD['net'][7][k][i])
##        avgLatDec /= len(statsPerMBD['net'][7][k])
##        y[f].append(avgLatDec)
##
##fig, ax = plt.subplots()
##
### We change the fontsize of minor ticks label 
##ax.tick_params(axis='both', which='major', labelsize=20)
##ax.tick_params(axis='both', which='minor', labelsize=20)
##
##
##ax.errorbar(x[1], y[1], yerr=np.std(nonAvgY[1]), marker='o', linestyle='solid', label='f=1')
##ax.errorbar(x[5], y[5], yerr=np.std(nonAvgY[5]), marker='x', linestyle='dotted', label='f=5')
##ax.errorbar(x[9], y[9], yerr=np.std(nonAvgY[9]), marker='^', linestyle='dashed', label='f=9')
##ax.errorbar(x[13], y[13], yerr=np.std(nonAvgY[13]), marker='+', linestyle='dashdot', label='f=13')
##
##
##ax.legend()
##
##
##ax.set_xlabel('Network connectivity (k)')
##ax.set_ylabel('Variation # bits transmitted (%)')
###ax.set_title('Line plot with error bars')
##
##plt.xlim([0, 50])
##plt.xticks([0,5,10,15,20,25,30,35,40,45,50])

##plt.show()

##x = {}
##y = {}
##nonAvgY = {}
##for f in [1, 5, 9, 13]:
##    x[f] = []
##    y[f] = []
##    nonAvgY[f] = []
##    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
##        if k < 2*f + 1:
##            continue
##        x[f].append(k)
##        avgLatDec = 0
##        for i in range(len(statsPerMBD['net'][11][k])):
##            avgLatDec += statsPerMBD['net'][11][k][i]
##            nonAvgY[f].append(statsPerMBD['net'][11][k][i])
##        avgLatDec /= len(statsPerMBD['net'][11][k])
##        y[f].append(avgLatDec)
##
##fig, ax = plt.subplots()
##
### We change the fontsize of minor ticks label 
##ax.tick_params(axis='both', which='major', labelsize=20)
##ax.tick_params(axis='both', which='minor', labelsize=20)
##
##
##ax.errorbar(x[1], y[1], yerr=np.std(nonAvgY[1]), marker='o', linestyle='solid', label='f=1')
##ax.errorbar(x[5], y[5], yerr=np.std(nonAvgY[5]), marker='x', linestyle='dotted', label='f=5')
##ax.errorbar(x[9], y[9], yerr=np.std(nonAvgY[9]), marker='^', linestyle='dashed', label='f=9')
##ax.errorbar(x[13], y[13], yerr=np.std(nonAvgY[13]), marker='+', linestyle='dashdot', label='f=13')
##
##
##ax.legend()
##
##
##ax.set_xlabel('Network connectivity (k)')
##ax.set_ylabel('Variation # bits transmitted (%)')
###ax.set_title('Line plot with error bars')
##
##plt.xlim([0, 50])
##plt.xticks([0,5,10,15,20,25,30,35,40,45,50])

# Fig. 6 (MBD.11)
#plt.savefig("fig6.pdf", bbox_inches='tight')
##plt.show()

############ New figures

##f = 1
##x = {}
##y = {}
##nonAvgY = {}
##for mbd in [7, 11]:
##    x[mbd] = []
##    y[mbd] = []
##    nonAvgY[mbd] = []
##
##    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
##        if k < 2*f + 1:
##            continue
##        x[mbd].append(k)
##        avgLatDec = 0
##        for i in range(len(statsPerMBD['net'][mbd][k])):
##            avgLatDec += statsPerMBD['net'][mbd][k][i]
##            nonAvgY[mbd].append(statsPerMBD['net'][mbd][k][i])
##        avgLatDec /= len(statsPerMBD['net'][mbd][k])
##        y[mbd].append(avgLatDec)
##
##fig, ax = plt.subplots()
##
### We change the fontsize of minor ticks label 
##ax.tick_params(axis='both', which='major', labelsize=20)
##ax.tick_params(axis='both', which='minor', labelsize=20)
##
##print(y[7])
##print(y[11])
##
##ax.errorbar(x[7], y[7], yerr=np.std(nonAvgY[7]), marker='o', linestyle='solid', label='MBD.7')
##ax.errorbar(x[11], y[11], yerr=np.std(nonAvgY[11]), marker='x', linestyle='dotted', label='MBD.11')
##
##ax.legend()
##
##
##ax.set_xlabel('Network connectivity')
##ax.set_ylabel('Variation # bits transmitted (%)')
###ax.set_title('Line plot with error bars')
##
##plt.xlim([0, 50])
##plt.xticks([0,5,10,15,20,25,30,35,40,45,50])
##
##plt.savefig("journal_mbd_7_11_varNet.pdf", bbox_inches='tight')
##plt.show()
##
##
##f = 1
##x = {}
##y = {}
##nonAvgY = {}
##for mbd in [7, 11]:
##    x[mbd] = []
##    y[mbd] = []
##    nonAvgY[mbd] = []
##
##    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
##        if k < 2*f + 1:
##            continue
##        x[mbd].append(k)
##        avgLatDec = 0
##        for i in range(len(statsPerMBD['lat'][mbd][k])):
##            avgLatDec += statsPerMBD['lat'][mbd][k][i]
##            nonAvgY[mbd].append(statsPerMBD['lat'][mbd][k][i])
##        avgLatDec /= len(statsPerMBD['lat'][mbd][k])
##        y[mbd].append(avgLatDec)
##
##fig, ax = plt.subplots()
##
### We change the fontsize of minor ticks label 
##ax.tick_params(axis='both', which='major', labelsize=20)
##ax.tick_params(axis='both', which='minor', labelsize=20)
##
##
##ax.errorbar(x[7], y[7], yerr=np.std(nonAvgY[7]), marker='o', linestyle='solid', label='MBD.7')
##ax.errorbar(x[11], y[11], yerr=np.std(nonAvgY[11]), marker='x', linestyle='dotted', label='MBD.11')
##
##ax.legend()
##
##
##ax.set_xlabel('Network connectivity')
##ax.set_ylabel('Variation latency  (%)')
###ax.set_title('Line plot with error bars')
##
##plt.xlim([0, 50])
##plt.xticks([0,5,10,15,20,25,30,35,40,45,50])
##
##plt.savefig("journal_mbd_7_11_varLat.pdf", bbox_inches='tight')
##plt.show()



##top_msgs_options[k][cur_options][i][1])

f = 9
x = {}
y = {}
x[1] = []
y[1] = []
first = True
nonAvgY = {}
nonAvg1 = {}
nonAvg1[1]= []
for mbd in [7, 8, 9, 11]:

    # k: 'N f k payloadSize'
    x[mbd] = []
    y[mbd] = []
    nonAvgY[mbd] = []

    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
        if k < 2*f + 1:
            continue

        if mbd == 7:
            options = "True\t"+"\t".join(['False']*5)+"\tTrue\t"+"\t".join(['False']*5)
        elif mbd == 8:
            options = "True\t"+"\t".join(['False']*6)+"\tTrue\t"+"\t".join(['False']*4)
        elif mbd == 9:
            options = "True\t"+"\t".join(['False']*7)+"\tTrue\t"+"\t".join(['False']*3)
        else:
            options = "True\t"+"\t".join(['False']*9)+"\tTrue\tFalse"

        options1 = "True\t"+"\t".join(['False']*11)

        options = '50\t1\t'+str(k)+'\t1024\t'+"\t".join(['True']*5)+'\t'+options+'\t'
        
        key = '50 1 '+str(k)+' 1024'
        x[mbd].append(k)
        if first:
            x[1].append(k)
        avgLatDec = 0
        avgLat1 = 0
            
        for i in range(len(top_lat_options[key][options])):
            avgLatDec += top_lat_options[key][options][i][1]
            nonAvgY[mbd].append(top_lat_options[key][options][i][1] / 1000)
            if first:
                avgLat1 += top_lat_options[key][options][i][0]
                nonAvg1[1].append(top_lat_options[key][options][i][0] / 1000)
        avgLatDec /= len(top_lat_options[key][options])
        y[mbd].append(avgLatDec / 1000)
        if first:
            avgLat1 /= len(top_lat_options[key][options])
            y[1].append(avgLat1 / 1000)
        

    first = False

fig, ax = plt.subplots(figsize=(10,6))

# We change the fontsize of minor ticks label 
ax.tick_params(axis='both', which='major', labelsize=20)
ax.tick_params(axis='both', which='minor', labelsize=20)


##ax.errorbar(x[1], y[1], yerr=np.std(nonAvg1[1]), marker='o', linestyle='solid', label='MBD.1')
##ax.errorbar(x[7], y[7], yerr=np.std(nonAvgY[7]), marker='x', linestyle='dotted', label='MBD.1+7')
##ax.errorbar(x[8], y[8], yerr=np.std(nonAvgY[8]), marker='^', linestyle='dashed', label='MBD.1+8')
##ax.errorbar(x[9], y[9], yerr=np.std(nonAvgY[9]), marker='+', linestyle='dashdot', label='MBD.1+9')
##ax.errorbar(x[11], y[11], yerr=np.std(nonAvgY[11]), marker='P', linestyle=':', label='MBD.1+11')

ax.errorbar(x[1], y[1], marker='o', linestyle='solid', linewidth=2, label='BDopt + MBD.1')
ax.errorbar(x[7], y[7], marker='x', linestyle='dotted', linewidth=2, label='BDopt + MBD.1/7')
ax.errorbar(x[8], y[8], marker='^', linestyle='dashed', linewidth=2, label='BDopt + MBD.1/8')
ax.errorbar(x[9], y[9], marker='+', linestyle='dashdot', linewidth=2, label='BDopt + MBD.1/9')
ax.errorbar(x[11], y[11], marker='P', linestyle=':', linewidth=2, label='BDopt + MBD.1/11')

ax.legend(prop={'size': 20})


ax.set_xlabel('Network connectivity (k)', fontsize=20)
ax.set_ylabel('Latency (ms)', fontsize=20)
#ax.set_title('Line plot with error bars')

plt.ylim([0, 350])
plt.xlim([25, 50])
plt.xticks([20,25,30,35,40,45,50])

plt.savefig("journal_mbd_1_7_8_9_11_lat.pdf", bbox_inches='tight')
#plt.show()


f = 9
x = {}
y = {}
x[1] = []
y[1] = []
first = True
nonAvgY = {}
nonAvg1 = {}
nonAvg1[1]= []
for mbd in [7, 8, 9, 11]:

    # k: 'N f k payloadSize'
    x[mbd] = []
    y[mbd] = []
    nonAvgY[mbd] = []

    for k in [4, 10, 16, 22, 28, 34, 40, 46]:
        if k < 2*f + 1:
            continue

        if mbd == 7:
            options = "True\t"+"\t".join(['False']*5)+"\tTrue\t"+"\t".join(['False']*5)
        elif mbd == 8:
            options = "True\t"+"\t".join(['False']*6)+"\tTrue\t"+"\t".join(['False']*4)
        elif mbd == 9:
            options = "True\t"+"\t".join(['False']*7)+"\tTrue\t"+"\t".join(['False']*3)
        else:
            options = "True\t"+"\t".join(['False']*9)+"\tTrue\tFalse"

        options1 = "True\t"+"\t".join(['False']*11)

        options = '50\t1\t'+str(k)+'\t1024\t'+"\t".join(['True']*5)+'\t'+options+'\t'
        
        key = '50 1 '+str(k)+' 1024'
        x[mbd].append(k)
        if first:
            x[1].append(k)
        avgLatDec = 0
        avgLat1 = 0
##        for a in top_lat_options[key]:
##            print(mbd)
##            print('a', a)
##            print('b', options)
##            print([a[i] for i in range(len(a)) if a[i] != options[i]])
##            print('a==b', a==b)
            
        for i in range(len(top_net_options[key][options])):
            avgLatDec += top_net_options[key][options][i][1]
            nonAvgY[mbd].append(top_net_options[key][options][i][1] / 1000)
            if first:
                avgLat1 += top_net_options[key][options][i][0]
                nonAvg1[1].append(top_net_options[key][options][i][0] / 1000)
        avgLatDec /= len(top_net_options[key][options])
        y[mbd].append(avgLatDec / 1000)
        if first:
            avgLat1 /= len(top_net_options[key][options])
            y[1].append(avgLat1 / 1000)
        

    first = False

fig, ax = plt.subplots(figsize=(10,6))

# We change the fontsize of minor ticks label 
ax.tick_params(axis='both', which='major', labelsize=20)
ax.tick_params(axis='both', which='minor', labelsize=20)

ax.errorbar(x[1], y[1], marker='o', linestyle='solid', linewidth=2, label='BDopt + MBD.1')
ax.errorbar(x[7], y[7], marker='x', linestyle='dotted', linewidth=2, label='BDopt + MBD.1/7')
ax.errorbar(x[8], y[8], marker='^', linestyle='dashed', linewidth=2, label='BDopt + MBD.1/8')
ax.errorbar(x[9], y[9], marker='+', linestyle='dashdot', linewidth=2, label='BDopt + MBD.1/9')
ax.errorbar(x[11], y[11], marker='P', linestyle=':', linewidth=2, label='BDopt + MBD.1/11')

##ax.errorbar(x[1], y[1], yerr=np.std(nonAvg1[1]), marker='o', linestyle='solid', label='MBD.1')
##ax.errorbar(x[7], y[7], yerr=np.std(nonAvgY[7]), marker='x', linestyle='dotted', label='MBD.1+7')
##ax.errorbar(x[8], y[8], yerr=np.std(nonAvgY[8]), marker='^', linestyle='dashed', label='MBD.1+8')
##ax.errorbar(x[9], y[9], yerr=np.std(nonAvgY[9]), marker='+', linestyle='dashdot', label='MBD.1+9')
##ax.errorbar(x[11], y[11], yerr=np.std(nonAvgY[11]), marker='P', linestyle=':', label='MBD.1+11')

ax.legend(prop={'size': 20})

ax.set_xlabel('Network connectivity (k)', fontsize=20)
ax.set_ylabel('Bandwidth consumption (kB)', fontsize=20)
#ax.set_title('Line plot with error bars')

plt.ylim([0, 80])
plt.xlim([25, 50])
plt.xticks([20,25,30,35,40,45,50])

plt.savefig("journal_mbd_1_7_8_9_11_net.pdf", bbox_inches='tight')
#plt.show()
